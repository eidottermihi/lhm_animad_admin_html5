<script>
    /**
     * Behavior, um einer beliebigen Liste (Read, Delete) alle Eigenschaften
     * wie Properties und Methoden zu geben, die es benötigt um mit dem Server zu
     * kommunizieren.
     *
     * @polymerMixinClass
     */
    /* @polymerMixin */
    let AnimadListBehavior = (superClass) => class extends superClass {

        static get properties() {
            return {
              data: {
                type: Array,
                value() {
                  return [];
                }
              },
              /*
                _filteredData enthält alle Objekte, die auf angegebene oder ausgewählte Filter zutreffen.
                Die Liste zeigt die Einträge aus _filteredData an.
              */
              _filteredData: {
                type: Array,
                value() {
                  return this.data;
                }
              },
              /*
                allFilters sind optionale (leeres Array), selektierbare Filter. Sie werden über ein Array definiert, Das
                die Struktur [{id, [{id, label}, {id2, label2}, ...}, {id2, [{id, label}, ...]}, ...] einhalten muss.
                GENERATOR: allFilters kann auch ein leeres Array [] enthalten. Dann wird der Filter-Button im search-panel nicht angezeigt.
              */
              allFilters: {
                type: Array,
                value() {
                  return [];
                }
              },
              /*
                _localizedFilters entspricht allFilters, aber die Werte in 'id' und 'label' sind durch lokalisierte Werte ersetzt worden.
              */
              _localizedFilters: {
                type: Array
              },
              /*
                _selectedFilters enthält die Information über alle ausgewählten Filter.
              */
              _selectedFilters: {
                type: Array,
                value() {
                  return [];
                }
              },
              /*
                _search enthält den String, der im Eingabe-Feld zum Suche eingegeben wurde.
              */
              _search: {
                type: String,
                value: ""
              },
              /**
              * Predefined search string. Will be shown in search field after page loading.
              */
              defaultSearch: {
                type: String
              },
              /*
                _search enthält den String, der im Eingabe-Feld zum Filtern eingegeben wurde.
              */
              _filterString: {
                type: String,
                value: ""
              },
              /*
                _disableDeleteButton deaktiviert (true) oder aktiviert (false) den Delete-Button
              */
              _disableDeleteButton: {
                type: Boolean,
                value: true
              },
              /*
               _deleteInfo enthält beim Löschen über Papierkorb die Information über den zu
               löschenden Datensatz. Nach Bestätigung oder Abbruch des Löschvorgangs wird
               die Information aus _deleteInfo wieder gelöscht.
              */
              _deleteInfo: {
                type: String,
                value: ""
              },
              /*
               _deleteItem enthält beim Löschen über Papierkorb den zu löschenden Datensatz.
               Nach Bestätigung oder Abbruch des Löschvorgangs wird _deleteItem wieder
               in den Initial-Zustand zurückgesetzt.
              */
              _deleteItems: {
                type: Array,
                value: []
              },
              /*
                _selectedItems enthält alle in der Liste selektierten Datensätze
              */
              _selectedItems: {
                type: Array,
                value() {
                  return [];
                }
              },
              /* _backendData enthält die Antwort des Backend-Aufrufs als JSON String*/
              _backendData: {
                type: Object,
                observer: '_backendDataChanged'
              },
              // backend stuff
              /*
                 die URL zum Backend
              */
               url: {
                 type: String,
                 value: ""
               },
               /*
                 multiSort gibt an, ob in der Tabelle nach mehreren Feldern sortiert
                 werden kann (multiSort = true) oder nicht (multiSort = false)
               */
               multiSort: {
                type: Boolean,
                value: false
               },
               /*
               * Wether to hide the whole list header. Set attribute "hide-header" to do so.
               */
               hideHeader: {
                type: Boolean,
                value: false
               },
               /**
          			 * Whether to hide the New button in header. Set attribute "hide-new" to do so.
          			 */
               hideNew: {
                type: Boolean,
                value: false
               },
               /**
          			 * Whether to hide the Delete buttons in header and list rows. Set attribute "hide-delete" to do so.
          			 */
               hideDelete: {
                type: Boolean,
                value: false
               },
               /**
         			 * Whether to hide the Filter button. Set attribute "hide-filter" to do so.
         			 */
         			hideFilter: {
         				type: Boolean,
         				value: false
         			},
               /**
         			 * Whether to disable the Filter button. Set attribute "disable-filter" to do so.
         			 */
         			disableFilter: {
         				type: Boolean,
         				value: false
         			},
               /**
         			 * Whether to disable the Delete button. Set attribute "disable-delete" to do so.
         			 */
         			disableDelete: {
         				type: Boolean,
         				value: false
         			},
              /**
         			 * Whether to disable the New button. Set attribute "disable-new" to do so.
         			 */
         			disableNew: {
         				type: Boolean,
         				value: false
         			},
         			/**
         			 * Icon shown in the search background
         			 */
         			icon: {
         				type: String,
         				value: 'search'
         			},
              /**
               * Whether to search data without filtering while loading or if user has to enter
               * search string before searching for data.
              */
              loadCompleteData: {
                type: Boolean,
                value: false
              },
              /**
               * Whether to show results text (e.g. 30 results found.) or not.
               */
              showResults: {
                type: Boolean,
                value: true
              },
              /**
               * String to show if 'showResults' is set to true.
               */
              _resultsText:{
                type: String
              },
              /**
               * Set to true as soon as data was searched.
               */
              _hasSearched: {
                type: Boolean,
                value: false
              },
              /**
               *
               */
              _errorToast: {
                  type: Object
              },
            }
        }

        // Observers
        static get observers() {
          return [
            '_selectionChanged(_selectedItems.length)',
            '_dataChanged(data.length)',
            '_initLocalizedFilter(allFilters)'
          ]
        }
        
        
        connectedCallback() {
            super.connectedCallback();
            this._errorToast = document.querySelector('animad-app').$.global_error_toast;
        }

        // refresh view and reset any delete information
        _dataChanged(dataLength) {
          // refresh list data
          this._filteredData = this.data;
          this._filter();

          // unselect all deleted items
          this._deselectItems(this._deleteItems);
//          for (var item of this._deleteItems) {
//            this.shadowRoot.querySelector('#animad-list').deselectItem(item);
//          }

          this._deleteItems = [];
          this._deleteInfos = "";

          if (this._hasSearched){
            // set results text
            if (dataLength > 1) {
              this._resultsText = dataLength+this.t('results_found_text');
            }
            else if (dataLength == 1) {
              this._resultsText = dataLength+this.t('results_one_found_text');
            }
            else {
              this._resultsText = this.t('no_results_found_text');
            }
          }
        }

        _deselectItems(items){
          this._selectedItems = [];
          
          // this is necessary as vaadin-grid doesn't unselect itself
          // when selected-items is assigned to an empty array...
          for (var item of items) {
            this.shadowRoot.querySelector('#animad-list').deselectItem(item);
          }
        }

        _hideSearchHeader(hideHeader){
          return hideHeader || this.loadCompleteData;
        }

        _hideFilterHeader(hideHeader){
          return hideHeader || !this.loadCompleteData;
        }
        // Selected/Unselected items in list
        _selectionChanged(nrSelectedItems) {
          this._disableDeleteButton = this.disableDelete || (nrSelectedItems === 0);
        }

        // Override to handle backendData individually
        _backendDataChanged(backendData, backendDataOld){
          // Assignmetn triggers observer _dataChanged
          this.data = backendData;
        }

        // Callback methods
        ready() {
          super.ready();
          this._search = this.defaultSearch;
          if (this.loadCompleteData){
            this._loadData();
          }
        }

        // Set text to show in search field
        _setSearchText(placeholder) {
          if (this._search && this._search.length > 0) {
            return this.defaultSearch;
          }
          return this.t(placeholder);
        }

        // Protected methods
        // localize all allFilters.filters.label
        _initLocalizedFilter(allFilters){
          if (allFilters) {
            for (var i in allFilters){
              allFilters[i].id = this.t(allFilters[i].id);
              var filters = allFilters[i].filters;
              for (var j in filters){
                filters[j].label = this.t(filters[j].label);
              }
            }
            this._localizedFilters = allFilters;
          }
        }

        // opens Dialog to confirm Deletion of selected rows
        _confirmDeleteSelected() {
          this._deleteItems = [];
          // loop over all items to delete
          for (var item of this._selectedItems) {
            // check if _filteredData contains selected item
            var index = this._filteredData.indexOf(item);

            if (index >= 0) {
              // yes: add it to deletedItems
              this._deleteItems.push(item);
            }
          }

          // check if selected item should be deleted
          // attention: this.$ necessary to enable it for Opera (https://github.com/PolymerElements/paper-dialog/issues/128)
          this.$.dialogDeleteSelected.open();
        }

        // opens Dialog to confirm Deletion of selected item (paper basket)
        _confirmDeleteRow(e) {
          // find clicked item by id in _filteredData
          var index = this._filteredData.findIndex(item => item.id == e.target.id);

          // get item of row where delete button was clicked
          //var item = this._filteredData[e.target.id];
          var item = this._filteredData[index];

          // set temporary delete information
          this._deleteItems = [item];

          // user must confirm that item should be deleted
          // attention: this.$ necessary to enable it for Opera (https://github.com/PolymerElements/paper-dialog/issues/128)
          this.$.dialogDeleteItem.open();
        }

        // Deletes all data that is contained in array _deleteItems
        _deleteSelectedRows() {
          var items = this._deleteItems;

          // loop over all items to delete
          for (var i in items) {
            var j = this.data.indexOf(items[i]);
            // Backend Call
            this._deleteData(this.data[j]);
          }
        }

        // reset any delete information
        _unsetTemporaryDeleteInfo() {
          this._deleteItem = [];
          this._deleteInfo = "";
        }

        // Backend methods
        // Search
        _loadData(){
          // TBD: error handling
          this._hasSearched = true;
          this._deselectItems(this._selectedItems);

          fetch(this.url, {
              method: 'GET',
              headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json'
              }
            }).then(response => response.json()).then(data => {
              this._backendData = data;
            }).catch(error => {
              this._error(this.t('list_action_search'), error.message);
            });;
        }

        _transferCellnameToFieldname(phrasesString, search) {
          var phrases = phrasesString.split(',');
          var start = search.length;
          var end = search.length;
          while (start >= 0 && end > -1) {
            var end = search.lastIndexOf(":", start);
            if (end > -1) {
              var start = search.lastIndexOf(" ", end);
              var oldsearch = search.substring(start, end).trim();
              var newsearch = oldsearch;
              for (var phrase of phrases) {
                phrase = phrase.replace(/"/g, '');
                var s = phrase.split(":");
                if(s.length > 1 && s[1].toLowerCase() == newsearch) {
                  newsearch = s[0];
                }
              }
              search = search.replace(oldsearch, newsearch);
            }
          }

          return search;
        }

        _fetchFuzzyData(search){
          this._hasSearched = true;
          this._deselectItems(this._selectedItems);

          var phrasesString = JSON.stringify(this._polyglot.phrases);
          var searchStr = this._transferCellnameToFieldname(phrasesString, search);
          var fuzzyUrl=this.url+"/search/findFullTextFuzzy?q='"+searchStr+"'";
          // TBD: error handling
          fetch(fuzzyUrl, {
              method: 'GET',
              headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
              }
            }
          ).then(response => response.json()
          ).then(data => {
            this._backendData = data;
          }).catch(error => {
            this._error(this.t('list_action_search'), error.message);
          });
        }

        // Delete
        _deleteData(item) {
          var url = this.url+'/'+item.id;
          fetch(url, {
            method: 'DELETE',
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'application/json'
            }
          }).then(response => {
            var index = response.url.lastIndexOf('/') + 1;
            var itemId = response.url.substring(index);

            if (response.ok) {
              // refresh view
              index = this.data.findIndex(item => item.id == itemId);
              this.splice('data', index, 1);
            }
            else {
              // notify user about error
              this._errorDelete(response.status, itemId);
            }
          }).catch(error => {
            this._error(this.t('list_action_delete'), error.message);
          });
        }

        /**
         * Der 'Toast', der bei Fehlern beim Löschen angezeigt wird.
         */
        _errorDelete(status, id) {
            this._errorToast.text = this.t('list_delete_error', { code: status, id: id });
            console.error(this._errorToast.text);
            this._errorToast.open();
        }

        /**
         * Der 'Toast', der bei Fehlern (allgemein) angezeigt wird.
         */
        _error(action, msg) {
            this._errorToast.text = this.t('list_error', { action: action });
            console.error(this._errorToast.text+"("+msg+")");
            this._errorToast.open();
        }
    };
</script>
