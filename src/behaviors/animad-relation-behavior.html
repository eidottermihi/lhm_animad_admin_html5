<link rel="import" href="../common-libs/traverson.html">
<link rel="import" href="../common-libs/traverson-hal.html">

<script>
    /**
     * Behavior, um einem Relation Element mit den notwendigen Eigenschaften 
     * auszustatten, um Relationen zu einem Zielobjekt hinzu zu fügen und
     * wieder zu entfernen. Um korrekt funktionieren zu können,
     * muss das Element die Properties 'domain' und 'entity' setzen:
     *
     * ```javascript
     *  _domain: {
     *    type: String,
     *    value: 'animad'
     *  },
     *  _entity: {
     *    type: String,
     *    value: 'enclosure'
     *  }
     * ```
     * 
     * Eingebunden wird das Mixin auf Klassenebene.
     * 
     * @polymerMixinClass
     */
    /* @polymerMixin */
    let AnimadRelationBehavior = (superClass) => class extends superClass {
        static get properties() {
            return {
                /*
                 * Der Daten-Cache.
                 */
                source: {
                    type: Array,
                    value() {
                        return [];
                    },
                    notify: true
                },
                /*
                 * Legt fest, ob die Daten vorab in den Speicher
                 * geladen werden. Dies ist bei kleinen Datenmengen
                 * durchaus sinnvoll. Die Daten werden in dem 
                 * Augenblick geladen, in dem die Komponente 
                 * gerendert wird.
                 */
                preload: {
                    type: Boolean,
                    value: false
                },
                /*
                 * Die übergerdnete Datenstruktur, um das Datenbinding
                 * durchgängig zu machen.
                 */
                data: {
                    type: Object,
                    notify: true
                },
                /*
                 * Das Traversal Objekt um die Daten initial zu laden.
                 */
                traversal: {
                    type: Object,
                    observer: '_loadRelationData'
                }
            }
        }

        connectedCallback() {
            super.connectedCallback();

            // Es muss ein eventlistener registriert werden,
            // um die selektierten Elemente verarbeiten zu
            // können.
            var e = this.shadowRoot.querySelector('paper-autocomplete');
            e.addEventListener('autocomplete-selected', this._appendItem);


            // Die generische Query Methode muss
            // durch eine eigen Methode überschrieben 
            // werden.
            e.queryFn = this._querySimple;
        }

        /*
         * Wird ein Traversal Objekt übergeben, dann werden automatisch 
         * die vorhandenen Daten geladen. Dies sind einerseits die zur 
         * Entität gehörenden Relationen, andererseits werden die möglichen
         * Relationen vorgeladen (sofern das 'preload' Attribut gesetzt ist).
         *
         * @param   das neue Traversal Objekt
         * @param   der bisherige Wert des Propeties (wird nicht benötigt)
         */
        _loadRelationData(traversal, oldV) {

            if (traversal) {

                // register HAL adapter in Traverson's media type registry
                traverson.registerMediaType(TraversonJsonHalAdapter.mediaType,
                    TraversonJsonHalAdapter);

                // Der Link Alias hat immer die Form
                // '[Name der Entity]List'. Dabei ist
                // [Name der Entity] klein geschrieben
                // und singular.
                var link = this._entity + 'List';

                // Bereits vorhandene Relationen werden 
                // in das 'data' Property gehängt.
                var path = 'data.' + this._entity + 's';

                // Die bereits verknüpften Relationen 
                // werden geladen.
                traversal
                    .continue()
                    .follow(link)
                    .getResource((error, resource) => {
                        if (error) {
                            console.warn('No luck with ' + link);
                        } else {
                            var array = resource._embedded[this._entity + 's'];
                            this.set(path, array);
                        }
                    });

                // Wenn die Auswahlliste vorgeladen werden soll, dann
                // kann dies über den '[Name der Entity]s' Link gemacht 
                // werden. 
                if (this.preload) {
                    traversal
                        .continue()
                        .follow(this._entity + 's')
                        .getResource((error, resource) => {
                            if (error) {
                                console.error('No luck with ' + this._entity + 's');
                            } else {
                                var array = resource._embedded[this._entity + 's'];
                                array.forEach((element) => {
                                    // der formatierte Text zur Auswahl
                                    var text = this._formatSuggester(element);
                                    // die id
                                    var value = element._links.self.href;

                                    // Die beiden Werte als Objekt in das 'source' Array 
                                    // speichern. Dieses Array ist Quelle für die 
                                    // Autocomplete Componente.
                                    this.push('source', { "text": text, "value": value, "entity": element })
                                });
                            }
                        });
                }
            }
        }

        /*
         * Sucht in einer vorgeladenen Quelle (Property preload 
         * ist auf 'true' gesetzt) nach Vorkommen einer Zeichenkette
         * im Attribut, dass im Property 'textProperty' angegeben wurde.
         *
         * @param die Auswahlliste Liste
         * @param die Such-Zeichenkette
         * @return ein Array der selektierten Elemente 
         */
        _querySimple(datasource, query) {
            return datasource.filter(x => x[this.textProperty].toLowerCase().indexOf(query) != -1);
        }

        /*
         * Listener Methode, um ein ausgewähltes Element der 
         * Zielstruktur hinzu zu fügen.
         * 
         * @param Event mit den notwendigen Daten 
         */
        _appendItem(event) {

            // Der 'host' des Elternknotens wird benötigt
            // um an die Properties zu kommen, da wir nicht
            // im 'this' scope sind.
            var h = this.parentNode.host;
            var name = 'data.' + h._entity + 's';
            var id = event.detail.value;

            // Wenn noch kein Attribut vorhanden ist, um
            // die Referenz zu speichern, so muss eines 
            // mit einem leeren Array erzeugt werden.
            if (!h.get(name)) {
                h.set(name, []);
            }

            // Wenn das Property 'save-relation-by-id' gesetzt ist...
            if (this.saveRelationById) {
                // Der key der ausgewählten Referenz wird
                // im Array gespeichert.
                h.push(name, id);
            } else {
                // Das Relationsobjekt wird gespeichert
                var item = this.source.find(x => x.value === id);
                h.push(name, item.entity);
            }

            // Textfeld leeren
            event.currentTarget.clear();
        }

        /*
         * Entfernt bereits ausgewähltes Element aus
         * der Zieldatenstruktur.
         *
         * @param Event mit den notwendigen Daten 
         */
        _removeItem(event) {
            var name = 'data.' + this._entity + 's';
            var index = event.target.dataset.item;
            console.log("index -> " + index);
            this.splice(name, index, 1);
        }
    }
</script>